Lenny Maynard
documentation.txt

The way DoubleMinPQ works is by within it, having 2 regular MinPQ for price and mileage, and an ArrayList. The MinPQ is the minimum priority queue taken from the book, minus the main method. The ArrayList is what actually stores the Car objects with all of the attributes (vin, make, model, etc.). The MinPQ hold PQNodes. These nodes represent cars but only contain the value to use to sort the respective PQ (price or mileage) and the index of its corresponding Car in the ArrayList. By doing this, the memory overhead is cut down significantly. Instead of storing 3 instances of each Car (in the 2 MinPQ and the ArrayList), there is only one full Car object stored with all of its strings, and the MinPQ only store 2 ints. When the full data of a car taken from one of the PQ is needed, it can be quickly found using its stored index. This results in an extra step in the lowest by make/model process, but in my opinion it is worth the huge savings in memory, especially if this were used for a real system with a large amount of cars.
	When a car is removed, its corresponding nodes in the 2 MinPQ are deleted and its position in the ArrayList is set to a preset “dud” car. This node has invalid strings for vin, make, model, and color, and the maximum integer values for price and mileage. This is done because of the way ArrayList works, outright removing that element would mess up the indices of the ArrayList, and setting it to null would produce null pointer exceptions. Since the vin, make, and model are all invalid, it will never show up because of something the user searches for. Since the price and mileage are the max int value, as long as there is any car in the system, it will have lower values than that and won’t come up from the get lowest price/mileage options. If all cars are removed from the system, it will act as if the “dud” cars are do not exist. 
	The downside of this implementation is that for updates, removes, and lowest by make and model functions, the process for accessing nodes within the MinPQ for price/mileage does not have ideal runtime. The min must be repeatedly taken off and stored in an ArrayList until the desired node is found, then they must be added back on. They are added back on in the order they were taken off so that the higher priority nodes are added first, resulting in less “swimming” being necessary to maintain the integrity of the priority queue. While this strategy is not the best for runtime, the implementation is fairly simple. This means less chance for bugs and fewer obscure corner cases that could potentially ruin the whole system. Overall, I believe that this whole DoublePQ system provides a reliable way to manage this system of cars, with a focus on conserving memory. 